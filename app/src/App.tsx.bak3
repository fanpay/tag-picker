import { useState, useEffect } from 'react';
import { useCombobox, useMultipleSelection } from 'downshift';
import './App.css';

// Custom Element interfaces for Kontent.ai
interface CustomElementContext {
  projectId: string;
}

interface CustomElementConfig {
  parentTagCodename?: string;
}

interface CustomElement {
  value: string;
  disabled: boolean;
  config?: CustomElementConfig;
}

// The CustomElement object is globally available.
// We declare it here to inform TypeScript about its existence and type.
declare global {
  interface Window {
    CustomElement: {
      init: (callback: (element: CustomElement, context: CustomElementContext) => void) => void;
      setValue: (value: string | null) => void;
      setHeight: (height: number) => void;
      onDisabledChanged: (callback: (disabled: boolean) => void) => void;
    };
  }
}

// Define the structure of a Tag item from the Kontent.ai Delivery API
interface Tag {
  system: {
    id: string;
    name: string;
    codename: string;
  };
  elements: {
    parent_tag?: {
      value: string[];
    };
    // Add other elements of the Tag content type if needed
  };
}

interface TagNode extends Tag {
  children: TagNode[];
}

function App() {
  const [disabled, setDisabled] = useState<boolean>(true);
  const [allTags, setAllTags] = useState<Tag[]>([]);
  const [parentTagCodename, setParentTagCodename] = useState<string | null>(null);
  const [selectedTags, setSelectedTags] = useState<Tag[]>([]);

  // Downshift multiple selection hook
  const {
    getSelectedItemProps,
    getDropdownProps,
    addSelectedItem,
    removeSelectedItem,
    selectedItems,
  } = useMultipleSelection({
    selectedItems: selectedTags,
    onStateChange({ selectedItems: newSelectedItems, type }) {
      switch (type) {
        case useMultipleSelection.stateChangeTypes.SelectedItemKeyDownBackspace:
        case useMultipleSelection.stateChangeTypes.SelectedItemKeyDownDelete:
        case useMultipleSelection.stateChangeTypes.DropdownKeyDownBackspace:
        case useMultipleSelection.stateChangeTypes.FunctionRemoveSelectedItem:
          setSelectedTags(newSelectedItems || []);
          break;
        default:
          break;
      }
    },
  });

  // Filter tags that are not already selected
  const availableTags = allTags.filter(
    tag => !selectedItems.some(selected => selected.system.codename === tag.system.codename)
  );

  // Downshift combobox hook
  const {
    isOpen,
    getLabelProps,
    getMenuProps,
    getInputProps,
    highlightedIndex,
    getItemProps,
  } = useCombobox({
    items: availableTags,
    itemToString: (item) => item?.system.name || '',
    defaultHighlightedIndex: 0,
    selectedItem: null,
    stateReducer(_state, actionAndChanges) {
      const { changes, type } = actionAndChanges;
      
      switch (type) {
        case useCombobox.stateChangeTypes.InputKeyDownEnter:
        case useCombobox.stateChangeTypes.ItemClick:
          return {
            ...changes,
            isOpen: true,
            highlightedIndex: 0,
            inputValue: '',
          };
        default:
          return changes;
      }
    },
    onStateChange({
      type,
      selectedItem: newSelectedItem,
    }) {
      switch (type) {
        case useCombobox.stateChangeTypes.InputKeyDownEnter:
        case useCombobox.stateChangeTypes.ItemClick:
        case useCombobox.stateChangeTypes.InputBlur:
          if (newSelectedItem) {
            addSelectedItem(newSelectedItem);
            setSelectedTags([...selectedItems, newSelectedItem]);
          }
          break;
        default:
          break;
      }
    },
  });

  // Store initial codenames until tags are loaded
  const [initialCodenames, setInitialCodenames] = useState<string[]>([]);

  useEffect(() => {
    const initCustomElement = () => {
      if (window.CustomElement) {
        window.CustomElement.init((element, context) => {
          // Set the initial value from Kontent.ai
          if (typeof element.value === 'string' && element.value) {
            let codenames: string[] = [];
            try {
              // Try to parse as a JSON array (new format)
              const parsedValue = JSON.parse(element.value);
              if (Array.isArray(parsedValue)) {
                codenames = parsedValue;
              }
            } catch {
              // If parsing fails, assume it's a single string (old format)
              codenames = [element.value];
            }
            setInitialCodenames(codenames);
          }

          // Get parentTagCodename from the custom element configuration
          if (element.config?.parentTagCodename) {
            setParentTagCodename(element.config.parentTagCodename);
          } else {
            console.error("parentTagCodename not configured in the custom element.");
          }

          // Set the initial disabled state
          setDisabled(element.disabled);

          // Set initial height for the iframe
          window.CustomElement.setHeight(180);

          // Fetch all tags from the Delivery API
          fetchTags(context.projectId);
        });

        // Subscribe to disabled state changes
        window.CustomElement.onDisabledChanged(setDisabled);
      } else {
        console.error("CustomElement SDK not found.");
      }
    };

    const addTagToParents = (tag: Tag, tagMap: Map<string, TagNode>) => {
      const parentCodenames = tag.elements.parent_tag?.value || [];
      const currentNode = tagMap.get(tag.system.codename);
      
      parentCodenames.forEach(parentCodename => {
        const parentNode = tagMap.get(parentCodename);
        if (parentNode && currentNode) {
          parentNode.children.push(currentNode);
        }
      });
    };

    const buildTagHierarchy = (tags: Tag[], tagMap: Map<string, TagNode>) => {
      tags.forEach(tag => {
        const parentCodenames = tag.elements.parent_tag?.value || [];
        if (parentCodenames.length > 0) {
          addTagToParents(tag, tagMap);
        }
      });
    };

    const getDescendants = (node: TagNode): Tag[] => {
      let descendants: Tag[] = [node];
      for (const child of node.children) {
        descendants = [...descendants, ...getDescendants(child)];
      }
      return descendants;
    };

    const fetchTags = async (projectId: string) => {
      try {
        const response = await fetch(`https://deliver.kontent.ai/${projectId}/items?system.type=_tag`);
        if (!response.ok) {
          throw new Error(`Failed to fetch tags. Status: ${response.status}`);
        }
        const data = await response.json();
        
        if (parentTagCodename) {
          const allFetchedTags: Tag[] = data.items;
          const tagMap = new Map<string, TagNode>();

          // Initialize tag map
          allFetchedTags.forEach(tag => {
            tagMap.set(tag.system.codename, { ...tag, children: [] });
          });

          // Build hierarchy
          buildTagHierarchy(allFetchedTags, tagMap);

          const rootNode = tagMap.get(parentTagCodename);
          if (rootNode) {
            setAllTags(getDescendants(rootNode));
          } else {
            setAllTags([]);
          }
        } else {
          setAllTags(data.items);
        }
      } catch (error) {
        console.error("Error fetching tags:", error);
      }
    };

    initCustomElement();
  }, [parentTagCodename]);

  // Convert initial codenames to tags when tags are loaded
  useEffect(() => {
    if (allTags.length > 0 && initialCodenames.length > 0) {
      const initialTags = allTags.filter(tag => 
        initialCodenames.includes(tag.system.codename)
      );
      setSelectedTags(initialTags);
      setInitialCodenames([]); // Clear initial codenames
    }
  }, [allTags, initialCodenames]);

  useEffect(() => {
    // Update the element's height whenever the content changes with a slight delay
    const updateHeight = () => {
      if (window.CustomElement) {
        // Calculate height more accurately
        const appElement = document.querySelector('.app');
        if (appElement) {
          // Base height calculation
          const baseHeight = 180; // Minimum height
          
          // Add height for each row of tags (approximately 40px per row)
          const tagsPerRow = Math.floor(400 / 120); // Assuming ~120px per tag
          const tagRows = Math.ceil(selectedItems.length / tagsPerRow);
          const tagsHeight = Math.max(40, tagRows * 40);
          
          // Add extra height if dropdown is open
          const dropdownHeight = isOpen ? Math.min(160, availableTags.length * 44) : 0;
          
          const totalHeight = baseHeight + tagsHeight + dropdownHeight;
          
          window.CustomElement.setHeight(Math.min(totalHeight, 500)); // Max height 500px
        }
      }
    };

    // Small delay to ensure DOM is updated
    const timeoutId = setTimeout(updateHeight, 100);
    return () => clearTimeout(timeoutId);
  }, [selectedItems, isOpen, availableTags.length]);

  useEffect(() => {
    // Send selected codenames to Kontent.ai
    if (window.CustomElement && selectedItems) {
      const selectedCodenames = selectedItems.map(tag => tag.system.codename);
      window.CustomElement.setValue(JSON.stringify(selectedCodenames));
    }
  }, [selectedItems]);

  return (
    <div className="app">
      <label {...getLabelProps()}>Select Tag(s)</label>
      <div className="autocomplete-container">
        <div className="selected-tags">
          {selectedItems.map((selectedItemForRender, index) => (
            <span
              key={selectedItemForRender.system.codename}
              {...getSelectedItemProps({
                selectedItem: selectedItemForRender,
                index,
              })}
              className="selected-tag"
            >
              {selectedItemForRender.system.name}
              <button
                type="button"
                className="tag-remove"
                onClick={(e) => {
                  e.stopPropagation();
                  removeSelectedItem(selectedItemForRender);
                  setSelectedTags(selectedItems.filter(item => item !== selectedItemForRender));
                }}
                disabled={disabled}
                aria-label={`Remove ${selectedItemForRender.system.name}`}
              >
                Ã—
              </button>
            </span>
          ))}
        </div>
        <div className="combobox-container">
          <input
            placeholder="Search for tags..."
            className="combobox-input"
            disabled={disabled}
            {...getInputProps(getDropdownProps({ preventKeyAction: isOpen }))}
          />
          {isOpen && (
            <ul className="suggestions-list" {...getMenuProps()}>
              {availableTags.map((item, index) => (
                <li
                  className={`suggestion-item ${
                    highlightedIndex === index ? 'highlighted' : ''
                  }`}
                  key={`${item.system.codename}${index}`}
                  {...getItemProps({ item, index })}
                >
                  <span>{item.system.name}</span>
                </li>
              ))}
            </ul>
          )}
        </div>
      </div>
    </div>
  );
}

export default App;