import { useState, useEffect } from 'react';
import './App.css';

// The CustomElement object is globally available.
// We declare it here to inform TypeScript about its existence and type.
declare global {
  interface Window {
    CustomElement: {
      init: (callback: (element: any, context: any) => void) => void;
      setValue: (value: string | null) => void;
      setHeight: (height: number) => void;
      onDisabledChanged: (callback: (disabled: boolean) => void) => void;
    };
  }
}

// Define the structure of a Tag item from the Kontent.ai Delivery API
interface Tag {
  system: {
    id: string;
    name: string;
    codename: string;
  };
  elements: {
    parent_tag?: {
      value: string[];
    };
    // Add other elements of the Tag content type if needed
  };
}

interface TagNode extends Tag {
  children: TagNode[];
}

function App() {
  const [selectedValue, setSelectedValue] = useState<string[]>([]);
  const [disabled, setDisabled] = useState<boolean>(true);
  const [allTags, setAllTags] = useState<Tag[]>([]);
  const [inputValue, setInputValue] = useState('');
  const [suggestions, setSuggestions] = useState<Tag[]>([]);
  const [parentTagCodename, setParentTagCodename] = useState<string | null>(null);

  useEffect(() => {
    const initCustomElement = () => {
      if (window.CustomElement) {
        window.CustomElement.init((element, context) => {
          // Set the initial value from Kontent.ai
          if (typeof element.value === 'string' && element.value) {
            let initialValue: string[] = [];
            try {
              // Try to parse as a JSON array (new format)
              const parsedValue = JSON.parse(element.value);
              if (Array.isArray(parsedValue)) {
                initialValue = parsedValue;
              }
            } catch (error) {
              // If parsing fails, assume it's a single string (old format)
              initialValue = [element.value];
            }
            setSelectedValue(initialValue);
          }

          // Get parentTagCodename from the custom element configuration
          if (element.config && element.config.parentTagCodename) {
            setParentTagCodename(element.config.parentTagCodename);
          } else {
            console.error("parentTagCodename not configured in the custom element.");
          }

          // Set the initial disabled state
          setDisabled(element.disabled);

          // Fetch all tags from the Delivery API
          fetchTags(context.projectId);

          // Update the element's height
          window.CustomElement.setHeight(document.documentElement.scrollHeight);
        });

        // Subscribe to disabled state changes
        window.CustomElement.onDisabledChanged(setDisabled);
      } else {
        console.error("CustomElement SDK not found.");
      }
    };

    const fetchTags = async (projectId: string) => {
      try {
        const response = await fetch(`https://deliver.kontent.ai/${projectId}/items?system.type=_tag`);
        if (!response.ok) {
          throw new Error(`Failed to fetch tags. Status: ${response.status}`);
        }
        const data = await response.json();
        if (parentTagCodename) {
          const allFetchedTags: Tag[] = data.items;
          const tagMap = new Map<string, TagNode>();

          allFetchedTags.forEach(tag => {
            tagMap.set(tag.system.codename, { ...tag, children: [] });
          });

          allFetchedTags.forEach(tag => {
            const parentCodenames = tag.elements.parent_tag?.value || [];
            if (parentCodenames.length > 0) {
              parentCodenames.forEach(parentCodename => {
                const parentNode = tagMap.get(parentCodename);
                const currentNode = tagMap.get(tag.system.codename);
                if (parentNode && currentNode) {
                  parentNode.children.push(currentNode);
                }
              });
            }
          });

          const getDescendants = (node: TagNode): Tag[] => {
            let descendants: Tag[] = [node];
            for (const child of node.children) {
              descendants = [...descendants, ...getDescendants(child)];
            }
            return descendants;
          };

          const rootNode = tagMap.get(parentTagCodename);
          if (rootNode) {
            setAllTags(getDescendants(rootNode));
          } else {
            setAllTags([]);
          }
        } else {
          setAllTags(data.items);
        }
      } catch (error) {
        console.error("Error fetching tags:", error);
      }
    };

    initCustomElement();
  }, [parentTagCodename]);

  useEffect(() => {
    // Update the element's height whenever the content changes
    if (window.CustomElement) {
      window.CustomElement.setHeight(document.documentElement.scrollHeight);
    }
  }, [selectedValue]);

  useEffect(() => {
    if (window.CustomElement) {
      window.CustomElement.setValue(JSON.stringify(selectedValue));
    }
  }, [selectedValue]);

  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const value = event.target.value;
    setInputValue(value);
    if (value) {
      const filteredSuggestions = allTags.filter(tag =>
        tag.system.name.toLowerCase().includes(value.toLowerCase()) &&
        !selectedValue.includes(tag.system.codename)
      );
      setSuggestions(filteredSuggestions);
    } else {
      setSuggestions([]);
    }
  };

  const handleSelectTag = (tag: Tag) => {
    setSelectedValue([...selectedValue, tag.system.codename]);
    setInputValue('');
    setSuggestions([]);
  };

  const handleRemoveTag = (codename: string) => {
    setSelectedValue(selectedValue.filter(item => item !== codename));
  };

  const getTagName = (codename: string) => {
    const tag = allTags.find(t => t.system.codename === codename);
    return tag ? tag.system.name : codename;
  };

  return (
    <div className="app">
      <label>Select Tag(s)</label>
      <div className="autocomplete-container">
        <div className="selected-tags">
          {selectedValue.map(codename => (
            <div key={codename} className="selected-tag">
              {getTagName(codename)}
              <button onClick={() => handleRemoveTag(codename)} disabled={disabled}>x</button>
            </div>
          ))}
        </div>
        <input
          type="text"
          value={inputValue}
          onChange={handleInputChange}
          disabled={disabled}
          placeholder="Search for tags..."
        />
        {suggestions.length > 0 && (
          <ul className="suggestions-list">
            {suggestions.map(tag => (
              <li key={tag.system.id} onClick={() => handleSelectTag(tag)}>
                {tag.system.name}
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
}

export default App;